{% load static %}

<head>
  <link href="{% static 'css/styles.css' %}" rel="stylesheet" />
  <!-- Include Font Awesome for icons -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />
  <style>
    #serviceDetails {
      font-family: Arial, sans-serif;
    }
    #serviceDetails .flex {
      align-items: center;
    }
    #serviceDetails h2 {
      margin: 0;
      flex-grow: 1;
    }
    #serviceDetails .bookmark-label {
      display: flex;
      align-items: center;
      font-size: 0.875rem;
      color: #4a5568;
      margin-right: 1rem;
    }
    #serviceDetails .bookmark-label input[type="checkbox"] {
      display: none;
    }
    #serviceDetails .bookmark-icon {
      cursor: pointer;
      font-size: 1.5rem;
      color: #cbd5e0;
      transition: color 0.3s ease;
    }
    #serviceDetails
      .bookmark-label
      input[type="checkbox"]:checked
      + .bookmark-icon {
      color: #4299e1;
    }
    #serviceDetails .space-y-1 p {
      margin-bottom: 0.5rem;
    }
    #serviceDetails #getDirections {
      display: inline-block;
      margin-top: 1rem;
      text-decoration: none;
    }
    #serviceDetails #reviewRating,
    #serviceDetails #reviewText {
      width: 100%;
      margin-bottom: 0.5rem;
    }
    #serviceDetails #submitReview {
      cursor: pointer;
    }
  </style>
</head>

<!-- Include serialized_items and userIsAuthenticated directly -->
<script>
  const itemsData = JSON.parse('{{ serialized_items|escapejs }}');
  const userIsAuthenticated = {{ user.is_authenticated|yesno:'true,false' }};
</script>

<div id="serviceDetails" class="bg-white rounded-lg shadow-md p-4 mb-8 hidden">
  <div class="flex justify-between items-start mb-4">
    <h2 id="serviceId" class="text-lg font-semibold" style="display: none">
      Id
    </h2>
    <h2 id="serviceName" class="text-lg font-semibold">Service Name</h2>

    <!-- Availability and Bookmark Icon -->
    <div class="flex items-center space-x-3">
      <span id="serviceAvailability" class="font-semibold hidden"
        >Currently Unavailable</span
      >

      {% if user.is_authenticated %}
      <label class="bookmark-label">
        <input type="checkbox" id="bookmarkCheckbox" />
        <i class="bookmark-icon fas fa-bookmark"></i>
      </label>
      {% endif %}
    </div>

    <button id="closeDetails" class="text-gray-500 hover:text-gray-700">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="h-6 w-6"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M6 18L18 6M6 6l12 12"
        />
      </svg>
    </button>
  </div>

  <div class="space-y-1 mb-4">
    <p class="text-sm">
      <strong>Address:</strong> <span id="serviceAddress">123 Main St</span>
    </p>
    <p class="text-sm">
      <strong>Type:</strong> <span id="serviceType">Homeless</span>
    </p>
    <p class="text-sm">
      <strong>Rating:</strong> <span id="serviceRating">4.5</span>
    </p>
    <p class="text-sm">
      <strong>Distance:</strong> <span id="serviceDistance">1.2 miles</span>
    </p>
    <a
      id="getDirections"
      href="#"
      target="_blank"
      rel="noopener noreferrer"
      class="inline-block bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 mt-2"
      >Get Directions</a
    >
    <div class="space-y-1 mb-4">
      <div id="serviceDescription" class="text-sm mt-2"></div>
    </div>
  </div>

  <h3 class="text-lg font-semibold mb-2">Leave a Review</h3>
  <div class="space-y-2 mb-4">
    <select id="reviewRating" class="w-full p-2 border rounded">
      <option value="">Select a rating</option>
      <option value="1">1 Star</option>
      <option value="2">2 Stars</option>
      <option value="3">3 Stars</option>
      <option value="4">4 Stars</option>
      <option value="5">5 Stars</option>
    </select>
    <textarea
      id="reviewText"
      class="w-full p-2 border rounded"
      placeholder="Write your review here..."
    ></textarea>
    <button id="submitReview" class="bg-blue-500 text-white px-4 py-2 rounded">
      Submit Review
    </button>
  </div>

  <div id="reviewsContainer" class="space-y-4"></div>
</div>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    function formatTimestamp(timestamp) {
      return new Date(timestamp).toLocaleString();
    }

    async function fetchAndDisplayReviews(serviceId, page = 1) {
      try {
        const response = await fetch(
          `/home/get_reviews/${serviceId}/?page=${page}`
        );
        if (!response.ok) {
          throw new Error(
            `Failed to fetch reviews. Status: ${response.status}`
          );
        }

        const { reviews, has_next, has_previous, current_page, username } =
          await response.json();

        const reviewsContainer = document.getElementById("reviewsContainer");
        reviewsContainer.innerHTML = "";

        if (reviews.length === 0) {
          reviewsContainer.innerHTML =
            '<p class="text-sm text-gray-500">No reviews yet.</p>';
          return;
        }

        reviews.forEach(review => {
            const reviewDiv = document.createElement('div');
            reviewDiv.classList.add('bg-white', 'rounded-lg', 'shadow', 'p-4', 'flex', 'justify-between', 'items-start', 'mb-4');
        
            // Container for the review content
            const contentContainer = document.createElement('div');
            contentContainer.classList.add('flex-grow'); // Allow content to take up the remaining space
        
            // Rating
            const rating = parseFloat(review.RatingStars).toFixed(2);
            const ratingElement = document.createElement('p');
            ratingElement.classList.add('text-yellow-400', 'font-semibold', 'inline'); // Inline to align with text
            ratingElement.textContent = `${rating} â˜…`;
            contentContainer.appendChild(ratingElement);
        
            // Review text
            const reviewText = document.createElement('p');
            reviewText.classList.add('text-sm', 'mt-1'); // Slight margin-top for spacing below rating
            reviewText.textContent = review.RatingMessage;
            contentContainer.appendChild(reviewText);
        
            // Meta info (timestamp and username)
            const timestamp = formatTimestamp(review.Timestamp);
            const meta = document.createElement('p');
            meta.classList.add('text-xs', 'text-gray-500', 'mt-1'); // Slight margin-top for separation
            meta.textContent = `By ${review.Username} on ${timestamp}`;
            contentContainer.appendChild(meta);
        
            // Append the content container to reviewDiv
            reviewDiv.appendChild(contentContainer);
        
            // Create the icon container if the current user is the author of the review
            if (username === review.Username) {
                const iconContainer = document.createElement('div');
                iconContainer.classList.add('flex', 'space-x-2', 'items-start'); // Align to the top
        
                // Edit icon
                const editIcon = document.createElement('i');
                editIcon.classList.add('fas', 'fa-edit', 'text-blue-500', 'cursor-pointer');
                editIcon.title = "Edit Review";
                editIcon.onclick = () => handleEditReview(review);
                iconContainer.appendChild(editIcon);
        
                // Delete icon
                const deleteIcon = document.createElement('i');
                deleteIcon.classList.add('fas', 'fa-trash', 'text-red-500', 'cursor-pointer');
                deleteIcon.title = "Delete Review";
                deleteIcon.onclick = () => handleDeleteReview(review);
                iconContainer.appendChild(deleteIcon);
        
                // Align the iconContainer to the top-right corner by appending it at the end of reviewDiv
                reviewDiv.appendChild(iconContainer);
            }
        
            // Add the complete reviewDiv to the reviews container
            reviewsContainer.appendChild(reviewDiv);
        });
        

        // Pagination controls
        const paginationDiv = document.createElement("div");
        paginationDiv.classList.add("flex", "justify-between", "mt-4");

        if (has_previous) {
          const prevButton = document.createElement("button");
          prevButton.classList.add(
            "bg-blue-500",
            "text-white",
            "px-4",
            "py-2",
            "rounded"
          );
          prevButton.textContent = "Previous";
          prevButton.addEventListener("click", () =>
            fetchAndDisplayReviews(serviceId, current_page - 1)
          );
          paginationDiv.appendChild(prevButton);
        }

        if (has_next) {
          const nextButton = document.createElement("button");
          nextButton.classList.add(
            "bg-blue-500",
            "text-white",
            "px-4",
            "py-2",
            "rounded"
          );
          nextButton.textContent = "Next";
          nextButton.addEventListener("click", () =>
            fetchAndDisplayReviews(serviceId, current_page + 1)
          );
          paginationDiv.appendChild(nextButton);
        }

        reviewsContainer.appendChild(paginationDiv);
      } catch (error) {
        console.error("Error fetching reviews:", error);
        alert("Failed to load reviews. Please try again.");
      }
    }

    // Expose the function globally
    window.fetchAndDisplayReviews = fetchAndDisplayReviews;

    async function handleEditReview(review) {
      try {
        const newRating = prompt(
          "Enter a new rating (1-5):",
          review.RatingStars
        );

        // Validate the rating input
        const ratingRegex = /^[1-5]$/; // Only allows values from 1 to 5

        if (!newRating || !ratingRegex.test(newRating)) {
          alert("Please enter a valid rating between 1 and 5.");
          return;
        }

        const newMessage = prompt("Enter a new message:", review.RatingMessage);
        if (!newMessage.trim()) {
          alert("A message is required.");
          return;
        }

        const response = await fetch(
          `/home/edit_review/${review["ReviewId"]}/`,
          {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": getCsrfToken(),
            },
            body: JSON.stringify({
              username: review.Username,
              rating: parseInt(newRating),
              message: newMessage,
            }),
          }
        );

        const data = await response.json();

        if (response.ok && data.success) {
          fetchAndDisplayReviews(review.ServiceId, 1); // Refresh the reviews
        } else {
          alert(data.error || "Failed to edit review.");
        }
      } catch (error) {
        console.error("Error editing review:", error);
        alert("An error occurred. Please try again.");
      }
    }
    function handleDeleteReview(review) {
      if (confirm("Are you sure you want to delete this review?")) {
        fetch(`/home/delete_review/${review["ReviewId"]}/`, {
          method: "DELETE",
          headers: {
            "X-CSRFToken": getCsrfToken(),
          },
          body: JSON.stringify({
            username: review.Username,
          }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              // console.log("fetching again after delete " + review.ServiceId);
              fetchAndDisplayReviews(review.ServiceId, 1); // Refresh the reviews
            } else {
              alert(data.error || "Failed to delete review.");
            }
          })
          .catch((error) => {
            console.error("Error deleting review:", error);
            alert("An error occurred. Please try again.");
          });
      }
    }

    // Add the showServiceDetails function
    function showServiceDetails(index) {
      const service = itemsData.find((item) => item.Id === index);
      if (!service) {
        console.error(`Service with index ${index} not found.`);
        return;
      }

      // Populate basic service details
      document.getElementById("serviceId").textContent = service.Id || "No ID";
      document.getElementById("serviceName").textContent =
        service.Name || "No Name";
      document.getElementById("serviceAddress").textContent =
        service.Address || "N/A";
      document.getElementById("serviceType").textContent =
        service.Category || "Unknown";
      document.getElementById("serviceRating").textContent =
        service.Ratings && service.Ratings !== 0
          ? parseFloat(service.Ratings).toFixed(2)
          : "N/A";
      document.getElementById("serviceDistance").textContent = service.Distance
        ? parseFloat(service.Distance).toFixed(2) + " miles"
        : "N/A";

     // console.log(service);

      const serviceAvailability = document.getElementById(
        "serviceAvailability"
      );
      if (service.IsActive === false) {
        serviceAvailability.textContent = "Currently Unavailable";
        serviceAvailability.classList.remove("text-green-500");
        serviceAvailability.classList.add("text-red-500");
      } else {
        serviceAvailability.textContent = "Available";
        serviceAvailability.classList.remove("text-red-500");
        serviceAvailability.classList.add("text-green-500");
      }
      serviceAvailability.classList.remove("hidden");

      const bookmarkCheckbox = document.getElementById("bookmarkCheckbox");

      if (bookmarkCheckbox && userIsAuthenticated) {
        // Set the initial checkbox state based on the bookmark status
        bookmarkCheckbox.checked = service.IsBookmarked;

        // Add event listener to the bookmark checkbox
        bookmarkCheckbox.onchange = function () {
          const action = bookmarkCheckbox.checked ? "add" : "remove";
          const serviceId = service.Id;

          fetch("/home/toggle_bookmark/", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": getCsrfToken(),
            },
            body: JSON.stringify({
              service_id: serviceId,
              action: action,
            }),
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                service.IsBookmarked = bookmarkCheckbox.checked;
              } else {
                // Revert the checkbox state if the request failed
                bookmarkCheckbox.checked = !bookmarkCheckbox.checked;
                alert(data.error || "Failed to toggle bookmark.");
              }
            })
            .catch((error) => {
              console.error("Error toggling bookmark:", error);
              // Revert the checkbox state if an error occurred
              bookmarkCheckbox.checked = !bookmarkCheckbox.checked;
              alert("An error occurred. Please try again.");
            });
        };
      } else if (bookmarkCheckbox) {
        // Hide the bookmark checkbox if the user is not authenticated
        bookmarkCheckbox.parentElement.style.display = true;
      }

      const descriptionElement = document.getElementById("serviceDescription");
      descriptionElement.innerHTML = ""; // Clear previous content

      const heading = document.createElement("h3");
      heading.textContent = "Additional Descriptive Details:";
      heading.style.marginBottom = "10px";
      heading.style.fontSize = "1.1em";
      heading.style.fontWeight = "bold";
      descriptionElement.appendChild(heading);

      // Check if Description exists and is an object
      if (service.Description && typeof service.Description === "object") {
        let hasDescription = false;
        const table = document.createElement("table");

        for (const [key, value] of Object.entries(service.Description)) {
          if (value !== null && value !== "") {
            hasDescription = true;
            const tr = document.createElement("tr");

            const th = document.createElement("th");
            th.textContent = `${key.replace(/_/g, " ")}:`;

            const td = document.createElement("td");
            td.innerHTML = value.replace(/\n/g, "<br>");

            tr.appendChild(th);
            tr.appendChild(td);
            table.appendChild(tr);
          }
        }

        if (hasDescription) {
          descriptionElement.appendChild(table);
        } else {
          descriptionElement.textContent = "No description available.";
        }
      } else {
        descriptionElement.textContent = "No description available.";
      }

      const getDirectionsBtn = document.getElementById("getDirections");

      if (service.MapLink) {
        getDirectionsBtn.href = service.MapLink;
        getDirectionsBtn.style.display = "inline-block";
      } else {
        getDirectionsBtn.href = "#";
        getDirectionsBtn.style.display = "none";
      }

      // Fetch and display reviews
      fetchAndDisplayReviews(service.Id, 1);

      const serviceDetailsDiv = document.getElementById("serviceDetails");
      if (serviceDetailsDiv) {
        serviceDetailsDiv.classList.remove("hidden");
        serviceDetailsDiv.classList.add("block");
      }
    }

    // Expose the function globally
    window.showServiceDetails = showServiceDetails;

    // Event listener for closeDetails button
    document.getElementById("closeDetails").addEventListener("click", () => {
      const serviceDetailsDiv = document.getElementById("serviceDetails");
      if (serviceDetailsDiv) {
        serviceDetailsDiv.classList.add("hidden");
        serviceDetailsDiv.classList.remove("block");
      }
    });

    // Event listener for submitReview button
    document
      .getElementById("submitReview")
      .addEventListener("click", async () => {
        const rating = document.getElementById("reviewRating").value;
        const message = document.getElementById("reviewText").value;
        const serviceId = document
          .getElementById("serviceId")
          .textContent.trim();

        if (rating === "" || message.trim() === "") {
          alert("Please provide both a rating and a message.");
          return;
        }

        const reviewData = {
          service_id: serviceId,
          rating: parseInt(rating),
          message: message,
        };

        try {
          const response = await fetch("/home/submit_review/", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": getCsrfToken(),
            },
            body: JSON.stringify(reviewData),
          });

          if (response.ok) {
            const result = await response.json();
            fetchAndDisplayReviews(serviceId, 1);
          } else {
            const error = await response.json();
            alert(error.error || "Failed to submit review.");
          }
        } catch (error) {
          console.error("Error submitting review:", error);
          alert("An error occurred. Please try again.");
        }
      });
  });

  // Function to get CSRF token from cookies
  function getCsrfToken() {
    const cookies = document.cookie.split("; ");
    for (const cookie of cookies) {
      const [name, value] = cookie.split("=");
      if (name === "csrftoken") return value;
    }
    return "";
  }
</script>
